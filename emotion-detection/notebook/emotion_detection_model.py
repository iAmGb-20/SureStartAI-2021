# -*- coding: utf-8 -*-
"""emotion-detection-model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k0UN6HZSHUIJ0MS3SXSTOa0yJZbf8lNk

**Emotion Detection Model generation**

In this notebook try to create Convolutional Neural Network Model from scratch by using Keras: the python deep learning api.
"""

#import necessary libraries
from __future__ import print_function
import keras
from keras.preprocessing.image import ImageDataGenerator
from keras.models import Sequential
from keras.layers import Dense,Dropout,Activation,Flatten,BatchNormalization
from keras.layers import Conv2D,MaxPooling2D
import os

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

!ls

train_data_dir='/content/drive/MyDrive/fer2013/train'
validation_data_dir='/content/drive/MyDrive/fer2013/validation'

"""Define important variables to be used throghout"""

num_classes=5
img_rows,img_cols=48,48
batch_size=32

"""The description for above variables are as follows:

- num_classses = 5 : This variable defines the number of classes or the emotions that we will be dealing with in training our model.

- img_rows,img_cols=48,48 : These variables define the size of the image array that we will be feeding to our neural network.

- batch_size=32: This variable defines the batch size.The batch size is a number of samples processed before the model is updated. The number of epochs is the number of complete passes through the training dataset. The size of a batch must be more than or equal to one and less than or equal to the number of samples in the training dataset.

Now we will be using Image Augmentation techniques om our dataset. Image data augmentation is a technique that can be used to artificially expand the size of a training dataset by creating modified versions of images in the dataset.The Keras deep learning neural network library provides the capability to fit models using image data augmentation via the ImageDataGenerator class.
"""

train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=30,
    shear_range=0.3,
    zoom_range=0.3,
    width_shift_range=0.4,
    height_shift_range=0.4,
    horizontal_flip=True,
    fill_mode='nearest')

validation_datagen = ImageDataGenerator(rescale=1./255)

"""The train_datagen variable will artificially expand the dataset using the following:

- rotation_range: Degree range for random rotations. Here i am using 30$^\circ$
- shear_range: Shear Intensity (Shear angle in counter-clockwise direction in degrees). Here i am using 0.3 as shear range.
- zoom_range: Range for random zoom..Here i am using 0.3 as zoom range.
width_shift_range: This shifts the images by a value across its width.
- height_shift_range : This shifts the images by a value across its height.
horizontal_flip: This flips the images horizontally.
- fill_mode: This is used to fill in the pixels after making changes to the orientation of the images by the above used methods. Here i am using 'nearest' as the fill mode as i am instructing it to fill the missing pixels in the image with the nearby pixels.

Here i am resclaing the validation data and not performing any other augmentaions as i want to check the model with raw data that is different from the data used in the training of the model.
"""

train_generator = train_datagen.flow_from_directory(
                        train_data_dir,
                        color_mode='grayscale',
                        target_size=(img_rows,img_cols),
                        batch_size=batch_size,
                        class_mode='categorical',
                        shuffle=True)

validation_generator = validation_datagen.flow_from_directory(
                                validation_data_dir,
                                color_mode='grayscale',
                                target_size=(img_rows,img_cols),
                                batch_size=batch_size,
                                class_mode='categorical',
                                shuffle=True)

"""Now i am using the **flow_from_directory()** method to load our dataset from the directory which is augmented and stored in the train_generator and validation_generator variables.**flow_from_directory()** actually takes the path to a directory & generates batches of augmented data. So here i am giving some options to the method to automatically change the dimention and divide it in the classes so that it is easier to feed in the model.

The options given are:

- directory: The directory of the dataset.
- color_mode: Here i am converting the images to grayscale as i am not interested in the color of the images but only the expressions.
- target_size: Convert the images to a uniform size.
- batch_size: To make baches of data to train.
- class_mode: Here i am using 'categorical' as the class mode as i am categorizing my images into 5 classes.
- shuffle: To shuffle the dataset for better training.

The dataset modifications is complete and now it's time to make the brain of the model i.e. the CNN Network.

So firstly i will define the type of model that i will be using. Here i am using a **Sequential** model which defines that all the layers in the network will be one after the other sequentially.
"""

model = Sequential()

"""Our network will consist of 7 blocks

**Block-1**
"""

model.add(Conv2D(32,(3,3),padding='same',kernel_initializer='he_normal',input_shape=(img_rows,img_cols,1)))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(Conv2D(32,(3,3),padding='same',kernel_initializer='he_normal',input_shape=(img_rows,img_cols,1)))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.2))

"""**Block-2**"""

model.add(Conv2D(64,(3,3),padding='same',kernel_initializer='he_normal'))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(Conv2D(64,(3,3),padding='same',kernel_initializer='he_normal'))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.2))

"""**Block-3**"""

model.add(Conv2D(128,(3,3),padding='same',kernel_initializer='he_normal'))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(Conv2D(128,(3,3),padding='same',kernel_initializer='he_normal'))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.2))

"""**Block-4**"""

model.add(Conv2D(256,(3,3),padding='same',kernel_initializer='he_normal'))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(Conv2D(256,(3,3),padding='same',kernel_initializer='he_normal'))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.2))

"""**Block-5**"""

model.add(Flatten())
model.add(Dense(64,kernel_initializer='he_normal'))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(Dropout(0.5))

"""**Block-6**"""

model.add(Dense(64,kernel_initializer='he_normal'))
model.add(Activation('elu'))
model.add(BatchNormalization())
model.add(Dropout(0.5))

"""**Block-7**"""

model.add(Dense(num_classes,kernel_initializer='he_normal'))
model.add(Activation('softmax'))

"""This seems a lot actually it is a lot.

Here i have used the layers of 7 types which are present in keras.layers.

The layers are:

- Conv2D( filters, kernel_size, strides=(1, 1), padding='valid', data_format=None, dilation_rate=(1, 1), activation=None, use_bias=True, kernel_initializer='glorot_uniform', bias_initializer='zeros', kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None, **kwargs )
- Activation(activation_type)
- BatchNormalization()
- MaxPooling2D(pool_size, strides, padding, data_format, **kwargs)
- Dropout(dropout_value)
- Flatten()
- Dense( units, activation=None, use_bias=True, kernel_initializer="glorot_uniform", bias_initializer="zeros", kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None, **kwargs)

**Block-1 layers in the order of occurrence are as follows :**

- Conv2D layer- This layer creates a convolutional layer for the network. Here i am creating a layer with 32 filters and a filter size of (3,3) with padding='same' to pad the image and using the kernel initializer he_normal. I have added 2 convolutional layers each followed by an activation and batch normalization layers.
- Activation layer - I am using a elu activation.
- BatchNormalization - Normalize the activations of the previous layer at each batch, i.e. applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.
- MaxPooling2D layer - Downsamples the input representation by taking the maximum value over the window defined by pool_size for each dimension along the features axis.Here i have used the pool_size as (2,2).
- Dropout: Dropout is a technique where randomly selected neurons are ignored during training. Here i am using dropout as 0.5 which means that it will ignore half of the neurons.

**Block-2 layers in the order of occurrence are as follows :**

- Same layers as block-1 but the convolutional layers have 128 filters.

**Block-3 layers in the order of occurrence are as follows :**

- Same layers as block-1 but the convolutional layers have 128 filters.

**Block-4 layers in the order of occurrence are as follows :**

- Same layers as block-1 but the convolutional layers have 256 filters.

**Block-5 layers in the order of occurrence are as follows :**

- Flatten layer - To flatten the output of the previous layers in a falat layer or in other words in the form of a vector.
Dense layer - A densely connected layer where each neuron is connected to every other neuron. Here i am using 64 units or 64 neurons with a kernal initializer - he_normal.
These layers are followed by activation layer with elu activation , batch normalization and finally a dropout with 50% dropout.

**Block-6 layers in the order of occurrence are as follows :**

- Same layers as blcok 5 but without flatten layer as the input for this block is already flattened.

**Block-7 layers in the order of occurrence are as follows :**

- Dense layer - Finally in the final block of the network i am using num_classes to create a dense layer having units=number of classes with a he_normal initializer.

- Activation layer - Here i am using a softmax layer which is used for multi-class classifications.

Too many layers, but finally it's over!!

Now to check the overall structure of the model:
"""

print(model.summary())

"""Now the only thing left is to compile and train the model. But first let's import some more things."""

from keras.optimizers import RMSprop,SGD,Adam
from keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau

"""Before compiling i will create 3 things using **keras.callbacks** class:

**Checkpoint( Function - ModelCheckpoint() )**

It will monitor the validation loss and will try to minimise the loss using the mode='min' property. When the checkpoint is reached it will save the best trained weights. Verbose=1 is just for visulaisation when the code created checkpoint.Here i am using it's following parameters:

- filepath: Path to save the model file.Here i am saving the model file with the name EmotionDetectionModel.h5
- monitor: Quantity to monitor.Here i am monitoring the validation loss.
- mode: One of {auto, min, max}. If save_best_only=True, the decision to overwrite the current save file is made based on either the maximization or the minimization of the monitored quantity.
- save_best_only: If save_best_only=True, the latest best model according to the quantity monitored will not be overwritten.
- verbose: int. 0: quiet, 1: update messages.

**Early Stopping ( Function - EarlyStopping() )**

This will stop the execution early by checking the following properties.

- monitor: Quantity to monitor.Here i am monitoring the validation loss.
- min_delta: Minimum change in the monitored quantity to qualify as an improvement, i.e. an absolute change of less than min_delta, will count as no improvement.Here i have given it 0.
- patience: Number of epochs with no improvement after which training will be stopped. Here i have given it 3.
- restore_best_weights: Whether to restore model weights from the epoch with the best value of the monitored quantity. If False, the model weights obtained at the last step of training are used.Here i have given it True.
- verbose: int. 0: quiet, 1: update messages.

**Reduce Learning Rate ( Function - ReduceLROnPlateau() )**

Models often benefit from reducing the learning rate by a factor of 2-10 once learning stagnates. This callback monitors a quantity and if no improvement is seen for a 'patience' number of epochs, the learning rate is reduced. I have used the following properties for this.

- monitor: To monitor a particular loss. Here i am monitoring the validation loss.
- factor: Factor by which the learning rate will be reduced. new_lr = lr * factor. Here i am using 0.2 as factor.
- patience: Number of epochs with no improvement after which learning rate will be reduced.Here i am using 3.
- min_delta: Threshold for measuring the new optimum, to only focus on significant changes.
- verbose: int. 0: quiet, 1: update messages.
"""

checkpoint = ModelCheckpoint('EmotionDetectionModel.h5',
                             monitor='val_loss',
                             mode='min',
                             save_best_only=True,
                             verbose=1)

earlystop = EarlyStopping(monitor='val_loss',
                          min_delta=0,
                          patience=3,
                          verbose=1,
                          restore_best_weights=True
                          )

reduce_lr = ReduceLROnPlateau(monitor='val_loss',
                              factor=0.2,
                              patience=3,
                              verbose=1,
                              min_delta=0.0001)

callbacks = [earlystop,checkpoint,reduce_lr]

"""**model.compile()**

It has the following arguments:

- loss: This value will determine the type of loss function to use in your code. Here i have categorical data in 5 categories or classes so i have used 'categorical_crossentropy' loss.
- optimizer: This value will determine the type of optimizer function to use in your code.Here i have used Adam optimizer with learning rate 0.001 as it is the best optimizer for categorical data.
- metrics: The metrics argument should be a list - you model can have any number of metrics.It is the list of metrics to be evaluated by the model during training and testing.Here i have used accuracy as metric which will compile mu model according to the accuracy.

**model.fit_generator()**

Fits the model on data yielded batch-by-batch by a Python generator.

It has the following arguments:

- generator: The train_generator object that we created earlier.
- steps_per_epochs: The steps to take on the training data in one epoch.
- epochs: The total number of epochs (pass though the whole dataset once).
- callbacks: The list containing all the callbacks that we created earlier.
- validation_data: The validation_generator object that we created earlier.
- validation_steps: The steps to take on the validation data in one epoch.
"""

model.compile(loss='categorical_crossentropy',
              optimizer = Adam(lr=0.001),
              metrics=['accuracy'])

nb_train_samples = 24176
nb_validation_samples = 3006
epochs=25

history=model.fit(
                train_generator,
                steps_per_epoch=nb_train_samples//batch_size,
                epochs=epochs,
                callbacks=callbacks,
                validation_data=validation_generator,
                validation_steps=nb_validation_samples//batch_size)